import { Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import ollama from 'ollama';
import * as fs from 'fs';

@Injectable()
export class MockTestService {
    constructor(private prisma: PrismaService) { }

    async generateTest(userId: string, courseId: string) {
        // 1. Fetch course details and context
        const course = await this.prisma.course.findUnique({
            where: { id: courseId },
            include: { lessons: true }
        });

        if (!course) throw new NotFoundException('Course not found');

        // Limit context to avoid token overflow
        // Only use descriptions from first 3 lessons for now (or randomize)
        const context = course.lessons.slice(0, 3).map(l => l.description).join('\n').substring(0, 2000);

        // 2. Prompt Ollama for MCQs
        const prompt = `Generate exactly 5 multiple-choice questions (MCQs) for a mock test on the course titled "${course.title}".
        Use this context: ${context}
        
        Return ONLY a JSON array of objects with this structure, no other text:
        [
          {
            "question": "string",
            "options": ["Option A", "Option B", "Option C", "Option D"],
            "correctAnswer": 0, // index of correct option (0-3)
            "explanation": "string"
          }
        ]`;

        try {
            const response = await ollama.chat({
                model: process.env.OLLAMA_MODEL || 'llama3', // Use robust model by default
                messages: [{ role: 'user', content: prompt }],
                stream: false,
                format: 'json'
            });

            let content = response.message.content;
            console.log('Ollama Response:', content);
            try { fs.writeFileSync('last_ollama_response.txt', content); } catch { }

            // Strip comments (// ...) from JSON if present
            content = content.replace(/\/\/.*$/gm, '');

            let mcqs;
            try {
                mcqs = JSON.parse(content);
            } catch (e) {
                console.warn('Direct JSON parse failed, attempting extraction...');
                try { fs.writeFileSync('last_parse_error.txt', `Parse Error: ${e.message}\nContent: ${content}`); } catch { }
                // Try to find array starting with object: [ { ... } ]
                const jsonMatch = content.match(/\[\s*\{[\s\S]*\}\s*\]/);
                if (jsonMatch) {
                    try {
                        mcqs = JSON.parse(jsonMatch[0]);
                    } catch (innerErr) {
                        throw new Error('Failed to parse extracted JSON: ' + innerErr.message);
                    }
                } else {
                    throw new Error('No JSON array found in response');
                }
            }

            // Handle case where model returns { "questions": [...] } instead of [...]
            if (!Array.isArray(mcqs) && mcqs.questions && Array.isArray(mcqs.questions)) {
                mcqs = mcqs.questions;
            }

            if (!Array.isArray(mcqs)) {
                throw new Error('AI response is not an array of questions');
            }

            // Validate questions structure
            const validMcqs = mcqs.filter((q: any) =>
                q.question && typeof q.question === 'string' &&
                Array.isArray(q.options) && q.options.length >= 2 &&
                typeof q.correctAnswer === 'number' &&
                q.correctAnswer >= 0 && q.correctAnswer < q.options.length
            );

            if (validMcqs.length === 0) {
                throw new Error('No valid questions generated by AI');
            }

            // 3. Save test to DB
            const mockTest = await this.prisma.mockTest.create({
                data: {
                    userId,
                    courseId,
                    title: `Mock Test: ${course.title}`,
                    totalPoints: validMcqs.length * 10,
                    questions: {
                        create: validMcqs.map((q: any) => ({
                            question: q.question,
                            options: q.options,
                            correctAnswer: q.correctAnswer,
                            explanation: q.explanation
                        }))
                    }
                },
                include: { questions: true }
            });

            return mockTest;
        } catch (error) {
            console.error('Mock Test Generation Error:', error);
            try { fs.writeFileSync('last_error.txt', `Error: ${error.message}\nStack: ${error.stack}`); } catch { }
            throw new InternalServerErrorException('Failed to generate mock test questions');
        }
    }

    async getTests(userId: string) {
        return this.prisma.mockTest.findMany({
            where: { userId },
            orderBy: { createdAt: 'desc' }
        });
    }

    async getTest(testId: string) {
        const test = await this.prisma.mockTest.findUnique({
            where: { id: testId },
            include: { questions: true }
        });
        if (!test) throw new NotFoundException('Test not found');
        return test;
    }

    async submitAnswer(questionId: string, answerIndex: number) {
        const question = await this.prisma.mockQuestion.findUnique({
            where: { id: questionId }
        });

        if (!question) throw new NotFoundException('Question not found');

        const isCorrect = question.correctAnswer === answerIndex;

        const updatedQuestion = await this.prisma.mockQuestion.update({
            where: { id: questionId },
            data: {
                userAnswer: answerIndex,
                isCorrect
            }
        });

        // Update score if correct
        if (isCorrect) {
            await this.prisma.mockTest.update({
                where: { id: question.testId },
                data: { score: { increment: 10 } }
            });
        }

        return updatedQuestion;
    }

    async finishTest(testId: string) {
        return this.prisma.mockTest.update({
            where: { id: testId },
            data: { isCompleted: true }
        });
    }
}
